use std::{fmt, fs, path::Path};

use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct EventsToml {
    pub triple_tap: TripleTapToml,
    pub optional_events: OptionalEventsToml,
}

#[derive(Debug, Deserialize)]
pub struct TripleTapToml {
    pub enabled: bool,
    pub min_gap_ms: u64,
    pub max_gap_ms: u64,
    pub last_max_gap_ms: u64,
    pub cooldown_ms: u64,
    pub debounce_ms: u64,
    pub seq_finish_debounce_ms: u64,
    pub gyro_veto_hold_ms: u64,
    pub thresholds: TapThresholdToml,
    pub weights: TapWeightToml,
}

#[derive(Debug, Deserialize)]
pub struct TapThresholdToml {
    pub jerk_l1_min: i32,
    pub jerk_strong_l1_min: i32,
    pub jerk_seq_cont_min: i32,
    pub prev_jerk_quiet_max: i32,
    pub gyro_l1_swing_max: i32,
}

#[derive(Debug, Deserialize)]
pub struct TapWeightToml {
    pub axis_weight: u16,
    pub single_tap_weight: u16,
    pub int1_weight: u16,
    pub tap_event_weight: u16,
    pub jerk_axis_weight: u16,
    pub jerk_only_weight: u16,
    pub seq_finish_weight: u16,
}

#[derive(Debug, Deserialize)]
pub struct OptionalEventsToml {
    pub pickup_enabled: bool,
    pub placement_enabled: bool,
    pub stillness_start_enabled: bool,
    pub stillness_end_enabled: bool,
    pub near_intent_enabled: bool,
    pub far_intent_enabled: bool,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ConfigCompilerError {
    Io(String),
    Parse(String),
    Validation(String),
}

impl fmt::Display for ConfigCompilerError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Io(message) => write!(f, "I/O error: {message}"),
            Self::Parse(message) => write!(f, "parse error: {message}"),
            Self::Validation(message) => write!(f, "validation error: {message}"),
        }
    }
}

impl std::error::Error for ConfigCompilerError {}

pub fn parse_events_file(path: &Path) -> Result<EventsToml, ConfigCompilerError> {
    let contents = fs::read_to_string(path)
        .map_err(|e| ConfigCompilerError::Io(format!("failed to read {}: {e}", path.display())))?;
    parse_events_str(&contents, Some(path))
}

pub fn parse_events_str(
    contents: &str,
    origin: Option<&Path>,
) -> Result<EventsToml, ConfigCompilerError> {
    toml::from_str::<EventsToml>(contents).map_err(|e| match origin {
        Some(path) => ConfigCompilerError::Parse(format!("invalid {}: {e}", path.display())),
        None => ConfigCompilerError::Parse(format!("invalid config TOML: {e}")),
    })
}

pub fn validate_config(events: &EventsToml) -> Result<(), ConfigCompilerError> {
    let t = &events.triple_tap;

    if t.min_gap_ms == 0 {
        return Err(validation("triple_tap.min_gap_ms must be > 0"));
    }
    if t.max_gap_ms < t.min_gap_ms {
        return Err(validation(
            "triple_tap.max_gap_ms must be >= triple_tap.min_gap_ms",
        ));
    }
    if t.last_max_gap_ms < t.max_gap_ms {
        return Err(validation(
            "triple_tap.last_max_gap_ms must be >= triple_tap.max_gap_ms",
        ));
    }
    if t.cooldown_ms == 0 {
        return Err(validation("triple_tap.cooldown_ms must be > 0"));
    }
    if t.debounce_ms == 0 {
        return Err(validation("triple_tap.debounce_ms must be > 0"));
    }
    if t.seq_finish_debounce_ms == 0 {
        return Err(validation("triple_tap.seq_finish_debounce_ms must be > 0"));
    }
    if t.gyro_veto_hold_ms == 0 {
        return Err(validation("triple_tap.gyro_veto_hold_ms must be > 0"));
    }

    let thr = &t.thresholds;
    if thr.jerk_l1_min <= 0
        || thr.jerk_strong_l1_min <= 0
        || thr.jerk_seq_cont_min <= 0
        || thr.prev_jerk_quiet_max <= 0
        || thr.gyro_l1_swing_max <= 0
    {
        return Err(validation(
            "all triple_tap.thresholds fields must be positive integers",
        ));
    }

    let w = &t.weights;
    if w.axis_weight == 0
        && w.single_tap_weight == 0
        && w.int1_weight == 0
        && w.tap_event_weight == 0
        && w.jerk_axis_weight == 0
        && w.jerk_only_weight == 0
        && w.seq_finish_weight == 0
    {
        return Err(validation(
            "triple_tap.weights must contain at least one non-zero weight",
        ));
    }

    Ok(())
}

pub fn render_generated_config(events: &EventsToml) -> String {
    let t = &events.triple_tap;
    let thr = &t.thresholds;
    let w = &t.weights;
    let e = &events.optional_events;

    format!(
        "// @generated by build.rs from config/events.toml\n\
         pub const EVENT_ENGINE_CONFIG: EventEngineConfig = EventEngineConfig {{\n\
             triple_tap: TripleTapConfig {{\n\
                 enabled: {enabled},\n\
                 min_gap_ms: {min_gap_ms},\n\
                 max_gap_ms: {max_gap_ms},\n\
                 last_max_gap_ms: {last_max_gap_ms},\n\
                 cooldown_ms: {cooldown_ms},\n\
                 debounce_ms: {debounce_ms},\n\
                 seq_finish_debounce_ms: {seq_finish_debounce_ms},\n\
                 gyro_veto_hold_ms: {gyro_veto_hold_ms},\n\
                 thresholds: TapThresholdConfig {{\n\
                     jerk_l1_min: {jerk_l1_min},\n\
                     jerk_strong_l1_min: {jerk_strong_l1_min},\n\
                     jerk_seq_cont_min: {jerk_seq_cont_min},\n\
                     prev_jerk_quiet_max: {prev_jerk_quiet_max},\n\
                     gyro_l1_swing_max: {gyro_l1_swing_max},\n\
                 }},\n\
                 weights: TapWeightConfig {{\n\
                     axis_weight: {axis_weight},\n\
                     single_tap_weight: {single_tap_weight},\n\
                     int1_weight: {int1_weight},\n\
                     tap_event_weight: {tap_event_weight},\n\
                     jerk_axis_weight: {jerk_axis_weight},\n\
                     jerk_only_weight: {jerk_only_weight},\n\
                     seq_finish_weight: {seq_finish_weight},\n\
                 }},\n\
             }},\n\
             optional_events: OptionalEventConfig {{\n\
                 pickup_enabled: {pickup_enabled},\n\
                 placement_enabled: {placement_enabled},\n\
                 stillness_start_enabled: {stillness_start_enabled},\n\
                 stillness_end_enabled: {stillness_end_enabled},\n\
                 near_intent_enabled: {near_intent_enabled},\n\
                 far_intent_enabled: {far_intent_enabled},\n\
             }},\n\
         }};\n",
        enabled = t.enabled,
        min_gap_ms = t.min_gap_ms,
        max_gap_ms = t.max_gap_ms,
        last_max_gap_ms = t.last_max_gap_ms,
        cooldown_ms = t.cooldown_ms,
        debounce_ms = t.debounce_ms,
        seq_finish_debounce_ms = t.seq_finish_debounce_ms,
        gyro_veto_hold_ms = t.gyro_veto_hold_ms,
        jerk_l1_min = thr.jerk_l1_min,
        jerk_strong_l1_min = thr.jerk_strong_l1_min,
        jerk_seq_cont_min = thr.jerk_seq_cont_min,
        prev_jerk_quiet_max = thr.prev_jerk_quiet_max,
        gyro_l1_swing_max = thr.gyro_l1_swing_max,
        axis_weight = w.axis_weight,
        single_tap_weight = w.single_tap_weight,
        int1_weight = w.int1_weight,
        tap_event_weight = w.tap_event_weight,
        jerk_axis_weight = w.jerk_axis_weight,
        jerk_only_weight = w.jerk_only_weight,
        seq_finish_weight = w.seq_finish_weight,
        pickup_enabled = e.pickup_enabled,
        placement_enabled = e.placement_enabled,
        stillness_start_enabled = e.stillness_start_enabled,
        stillness_end_enabled = e.stillness_end_enabled,
        near_intent_enabled = e.near_intent_enabled,
        far_intent_enabled = e.far_intent_enabled,
    )
}

pub fn generate_from_path(path: &Path) -> Result<String, ConfigCompilerError> {
    let events = parse_events_file(path)?;
    validate_config(&events)?;
    Ok(render_generated_config(&events))
}

fn validation(message: &str) -> ConfigCompilerError {
    ConfigCompilerError::Validation(message.to_string())
}
